Chapitre 4 : Appels systèmes

Exercice : un premier appel système qui ne retourne pas

Question 4-1 : OK
Question 4-2 : OK
Question 4-3 : OK
Question 4-4 : OK

Question 4-5 : OK, le test fonctionne correctement.

Exercice : un appel système qui retourne

Question 4-6 : OK

Question 4-7 :
La valeur qui a été stockée dans LR est écrasée lors du traitement
de l'interruption. De ce fait, lorsqu'on souhaite retourner en mode
USER, l'OS ne sait pas où retourner.

Question 4-8 :

Le registre SPSR n'apparaît car le mode d'exécution est celui du USER,
et ce mode d'exécution ne possède pas de registre SPSR contrairement
au mode SVC.

Question 4-9 : OK

Question 4-10 :

Non, il n'y a pas besoin de sauver explicitement le registre CPSR dans
le registre SPSR, car cela est fait automatiquement lors du passage
du mode USER à un quelconque mode privilégié. C'est l'une des premières
instructions qui est réalisée lors d'un tel changement de mode.

Question 4-11 : OK

Question 4-12 :
1er passage : 0x9464
2ème passage : 0x9454
3ème passage : 0x9444

On constate une décroissance du registre SP dans le mode SVC.

En effet, lorsqu'on rentre dans la fonction swi_handler(), un prologue
et un épilogue sont générés, notamment pour laisser une certaine
place pour les paramètres dans SP. Sauf que lors du ldmfd, on modifie
pc, donc l'épilogue n'est jamais effectué. La solution est de supprimer
le prologue et l'épilogue en utilisant l'attribut "naked" car en soit,
on n'a pas besoin de toucher au registre SP.

Question 4-13 : OK

Exercice : un appel système avec passage de paramètres

Question 4-14 : OK

Question 4-15 :

Etat de la pile au début de la fonction do_sys_settime() :

0x946c: 0x00000003      0x00000010      0x00000010      0x00000040
0x947c: 0x000080a0      0x000080a4      0x000080b4      0x000080ac
0x948c: 0x000080a8      0x000080b0      0x00000000      0x00000000
0x949c: 0x00000000      0x00008a7c      0x00000000      0x00000000
0x94ac: 0x00000000      0x00000000      0x00000000      0x00000000

Les valeurs qu'on retrouve sont logiques, on a bien dans R0 
la valeur de l'interruption de sys_settime() qui est 3 et
dans R1, la valeur du paramètre date_ms.

Question 4-16 :

L'état de la pile change au cours de la fonction. La valeur de
R1 est par exemple écrasée. C'est mauvais, car nous avons
enregistré la valeur du sommet de la pile dans R1.

Question 4-17 :

ATTENTION, quand on veut stocker la variable date_ms pour settime,
il est stocké "0x4000000010" au lieu de 0x10. Pouquoi donc ?
C'est normal car notre date est codée sur 2 cases mémoires (une case
mémoire = 32 bits et date_ms est un uint64_t). On n'avait pas
vraiment explicité le format de date_ms envoyé dans sys_settime !
En explicitant correctement uint64_t, ça fonctionne.

Question 4-18 : OK
Question 4-19 : OK
Question 4-20 : OK
Question 4-21 : OK
