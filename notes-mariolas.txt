CHAPITRE 2
================================================================================

Q2-2 :

Noter les adresses de ...
Début du code : 0x8000
Fin du code : 0x9180
Début des var globales non init : 0x9184
Fin de ça : 0x9194
Début des fonctions de kmain : 0x909c

================================================================================

Q2-3 :

Quels registres sont utilisés par la fonction div() ?
appel : r3, r2, r1, r0
r2 et r3 registres de travail (stocke les valeurs courantes, sert pour les
calculs)

Les valeurs de ces registres ?
r3 stocke tour à tour remainder et result et divisor
r2 stocke remainder
r1 stocke divisor
r0 stocke la valeur de retour (en accord avec convention d'appel)

Quel registre le compilateur a-t’il décidé d’utiliser pour la variable result ?
Pendant la boucle, result est stocké dans r3
Pour le retour, stocké dans r0

================================================================================

Q2-4 :

Pile en adresses décroissantes.

Plus petite adresse : 0x95ac (ou 95d4, débat) (sous-fonction la plus basse, div)

SP pointe sur la dernière case pleine (cf doc ARM)

================================================================================

Q2-5 :

compute_volume empile lr avant de s'éxécuter
div ne le fait : pas besoin car il n'appelle pas de fonction donc pas
d'écrasement de lr !

Avant appel de kmain, sp pointe vers 0x95e4

Dans la pile, dans le sens des @ decrois :
kmain, fonct principale, avec lr et ses var locales
compute-vol, appelée par kmain, avec lr et ses var locales
div, appelée par compute_vol, avec ses var locales
(chaque fonction a sa pile)
(avant appel, on sauvegarde les reg)

================================================================================

Q2-6 :

L'appel d'une fonction (commande asm bl) fait une màj de lr (link register)

================================================================================

Q2-7 :

Le programme ne retourne pas correctement car on n'empile pas lr.
Pour corriger cela on doit le faire (soit manuellement soit en utilisant
bl et pas b) => ça marche.

================================================================================

Q2-8 :

Voir le code ! Ça marche.

================================================================================

Q2-9 :

On perd la sauvegarde de contexte (lr, sp, pc, registres) et leur restauration.
Une fonction naked peut modifier les reg de la fonction appelante.
Impossible donc de coder en C après une naked.
Mais très utile pour récupérer le contexte de la fonction précédente !<

================================================================================

Q2-10 / 2-11:

Nous passons bien deux fois par bidule.
Nous sommes très convaincus.

================================================================================

Q2-12 :

.run-test.sh ../test/kmain-bidule.c ../test/bidule-called-twice.gdb

/!\ /!\ /!\ Le $0 est le 1er param, soit la commande elle-même !  /!\ /!\ /!\
#mathieu

================================================================================
================================================================================

CHAPITRE 3 :
================================================================================

Q3-1 :

cpsr à 0x400001df au début de kmain
Selon le sujet de TP, la fin en 0xF (=0b1111) signifie "mode system"
On est en mode système !
Ça se tient, on a encore rien exécuté.

================================================================================

Q3-2 :

Avant la magouille :
cpsr à 0x400001df
sp à 0X9620

Après :
cpsr à 0x400001d3
sp à 0X9420

On est en mode supervisor (SVC)
La valeur de cpsr est cohérente (f->3 <=> 1111->0011)

================================================================================

Q3-3 :

LR avant (en mode system) : 0x8098

LR après (en mode supervisor) : 0x0

C'est très cohérent, car lorsqu'on passe en mode exception depuis le mode system
on ne modifie pas le reg LR. Or ce reg est propre au mode d'exception, donc ne
contient rien à ce moment là car pas encore utilisé.

LR pointe au début du code de boot du noyau (0x8000).

================================================================================

Q3-4 :

On reste en mode user. En effet, le mode SVC est celui où se place le processeur
après une interruption logicielle (swi). Et le mode user ne peut pas déclencher
de swi.

================================================================================

Q3-5 :

On ne peut pas accéder au spsr, car on est en mode system et que ce reg
n'existe pas en mode system (utilisé que pour les modes d'exception).

(On a utilisé la commande asm "mrs")

================================================================================

Q3-6 :

Valeurs de CPSR :
Au début de kmain : 0x000001df (nzcs...AIF[SYSTEM])
Après passage en svc : 0x000001d3 (nzcs...AIF[SVC])
Après passage en user : 0x000001d0 (nzcs...AIF[USER])

================================================================================
================================================================================

CHAPITRE 4 :
================================================================================

Q4-1 à 4-5 :

NB :
-Pour reboot, saut à 0x8000 avec màj reg de statut
-Inclure "util.h" pour utiliser PANIC()

Q4-5 : test OK \o/

================================================================================

Q4-6 à 4-13 :

Q4-10 : Pas nécessaire de sauvegarder explicitement le reg de statut cpsr car
il est automatiquement sauvegardé dans spsr. En quittant le mode svc (post-swi)
on revient en mode user de manière transparente.

Q4-12 :
0x93b8
0x93a8 -> on remonte dans la pile
0x9398 -> yeah

Le soucis est que le handler, comme toute fonction, fait ses propres
sauvegardes et restaurations de contexte. La sauvegarde est faite, mais,
déjà elle ne sert à rien (même si elle ne fait pas de mal), et surtout
lors de notre resaturation perso (semi-manuelle) on restaure le PC.
Le code de restauration du handler ne peut donc pas être exécuté.
Pour régler ce problème on utilise l'attribut "tout nu" sur le handler !

================================================================================

Exo terminé, tous les tests sont OK.
